import { __awaiter, __generator } from "tslib";
import { SecretClient } from "../../src";
import * as fs from "fs";
import { DefaultAzureCredential } from "@azure/identity";
function writeFile(filename, text) {
    return new Promise(function (resolve, reject) {
        fs.writeFile(filename, text, function (err) {
            if (err)
                reject(err);
            else
                resolve();
        });
    });
}
function readFile(filename) {
    return new Promise(function (resolve, reject) {
        fs.readFile(filename, function (err, data) {
            if (err)
                reject(err);
            else
                resolve(data);
        });
    });
}
export function delay(t, value) {
    return new Promise(function (resolve) { return setTimeout(function () { return resolve(value); }, t); });
}
function main() {
    return __awaiter(this, void 0, void 0, function () {
        var credential, vaultName, url, client, secretName, backupResult, deletePoller, backupContents, result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    credential = new DefaultAzureCredential();
                    vaultName = process.env["KEYVAULT_NAME"] || "<keyvault-name>";
                    url = "https://" + vaultName + ".vault.azure.net";
                    client = new SecretClient(url, credential);
                    secretName = "StorageAccountPassword";
                    // Create our secret
                    return [4 /*yield*/, client.setSecret(secretName, "XYZ789")];
                case 1:
                    // Create our secret
                    _a.sent();
                    return [4 /*yield*/, client.backupSecret(secretName)];
                case 2:
                    backupResult = _a.sent();
                    // Write the backup to a file
                    return [4 /*yield*/, writeFile("secret_backup.dat", backupResult)];
                case 3:
                    // Write the backup to a file
                    _a.sent();
                    // Delete the secret
                    console.log("about to delete");
                    return [4 /*yield*/, client.beginDeleteSecret(secretName)];
                case 4:
                    deletePoller = _a.sent();
                    return [4 /*yield*/, deletePoller.pollUntilDone()];
                case 5:
                    _a.sent();
                    // Purge the deleted secret
                    console.log("about to purge");
                    return [4 /*yield*/, client.purgeDeletedSecret(secretName)];
                case 6:
                    _a.sent();
                    return [4 /*yield*/, delay(30000)];
                case 7:
                    _a.sent();
                    // Read our backup from a file
                    console.log("about to restore secret");
                    return [4 /*yield*/, readFile("secret_backup.dat")];
                case 8:
                    backupContents = _a.sent();
                    return [4 /*yield*/, client.restoreSecretBackup(backupContents)];
                case 9:
                    result = _a.sent();
                    console.log("Restored secret: ", result);
                    // If we don't want to purge the secret later, we don't need to wait until this finishes
                    return [4 /*yield*/, client.beginDeleteSecret(secretName)];
                case 10:
                    // If we don't want to purge the secret later, we don't need to wait until this finishes
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    });
}
main().catch(function (err) {
    console.log("error code: ", err.code);
    console.log("error message: ", err.message);
    console.log("error stack: ", err.stack);
});
//# sourceMappingURL=backupAndRestore.js.map